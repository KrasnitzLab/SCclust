#'Identify clones in hierarchical tree.
#'
#'Based on hierarchical clustering, identify the hard/soft clones.
#'@param hc The hclust objects with new items added generated by \code{hclust_tree}.
#'@param fdrthresh FDR criterion for clone nodes. Default: -2.
#'@param sharemin A feature is considered shared if present in share_min fraction of leaves in a node.Default: 0.90.
#'@param nshare Minimal number of shared features in a clone node. Default: 3.
#'@param bymax Logical. If TRUE (Default), use maximal of mean FDR for the node to find clones.
#'@param climbfromsize An integer.
#'@param climbtoshare An integer.
#'@return A hclust object.
#'@export



find_clones <- function(hc, fdrthresh = -2, 
    sharemin = 0.85, nshare = 3, bymax = T,
                       climbfromsize = 2, climbtoshare = 3){

  # fdrthresh: FDR criterion for clone nodes
  # share_min: A feature is considered shared if present in share_min fraction 
  #            of leaves in a node
  # nshare: Minimal number of shared features in a clone node
  # bymax: TRUE, Use maximal of mean FDR for the node to find clones?
  # climbfromsize
  # climbtoshare



  # Number of features (approximately) shared across the node
  # leaves of the node together with the shared features form a bicluster
  count_pins_share <- colSums(hc$sharing > sharemin)



  # A node is considered compliant if FDR is below and its sharing across above 
  # threshod for the node and all its descendants
#  if(bymax){
#    node_compliant <- (hc$maxfdr < fdrthresh & 
#          (count_pins_share - count_pins_share[nrow(hc$merge)]) > nshare)
#  } else {
#    node_compliant <- (hc$meanfdr < fdrthresh & 
#          (count_pins_share - count_pins_share[nrow(hc$merge)]) > nshare)
#  }

  if (bymax) { 
    node_compliant <- (hc$mergefdr < fdrthresh & count_pins_share > nshare)
  } else { 
    node_compliant <- (hc$meanfdr < fdrthresh & count_pins_share > nshare)
  }

  leftchild <- (hc$merge[,1] < 0)
  leftchild[hc$merge[,1] > 0] <- node_compliant[hc$merge[hc$merge[,1] > 0, 1]]

  rightchild <- (hc$merge[,2] < 0)
  rightchild[hc$merge[,2] > 0] <- node_compliant[hc$merge[hc$merge[,2] > 0, 2]]

  new_node_compliant <- node_compliant & leftchild & rightchild

  while(!all(new_node_compliant == node_compliant)){
    node_compliant <- new_node_compliant

    leftchild <- (hc$merge[,1] < 0)
    leftchild[hc$merge[,1] > 0] <- node_compliant[hc$merge[hc$merge[,1] > 0, 1]]

    rightchild <- (hc$merge[,2] < 0)
    rightchild[hc$merge[,2] > 0] <- node_compliant[hc$merge[hc$merge[,2] > 0, 2]]

    new_node_compliant <- node_compliant & leftchild & rightchild
  }


  #Clone nodes are maximum compliant nodes
  clone_nodes <- setdiff((1:nrow(hc$merge))[node_compliant],
                         c(hc$merge[node_compliant, 1], hc$merge[node_compliant, 2]))
  hc$fdrthresh <- fdrthresh
  hc$clonenodes <- clone_nodes
  hc$bymax <- bymax
  hc$count_pins_share <- count_pins_share
  hc$sharemin <- sharemin
  hc$nshare <- nshare

  if(!is.null(hc$clonenodes)){
    hc$softclones <- hc_climb(
        hc, minsize = climbfromsize, 
        minshare = climbtoshare + hc$count_pins_share[nrow(hc$merge)])
  }

  return(hc)
}
